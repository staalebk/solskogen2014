; Coding for the trusty 6502
	processor 6502

; Zero page defines:
	SEG.U VARS
	ORG $80
intcount1	ds 1
intcount2	ds 1
scrollbit	ds 1
scrollchr	ds 1
scrollpos   ds 1
scene		ds 1

	echo "----",($100 - *) , "bytes of RAM left"
	SEG CODE

; Lets make this stuff autoload address on 4096
	SEG	
	org $0801
	.byte $0c,$08,$0a,$00,$9e,$20,$34,$30,$39,$36,$00,$00,$00
	
; Our entry point
	org $1000
	lda #$00
	tax
	lda #$00
	tay
	lda #$0B
	jsr $C357

	
	
; clear interrupts
	sei
	lda #$7f
	sta $dc0d	;disable timer interrupts which can be generated by the two CIA chips
	sta $dd0d	;the kernal uses such an interrupt to flash the cursor and scan the keyboard, so we better
				;stop it.	
	lda $dc0d	;by reading this two registers we negate any pending CIA irqs.
	lda $dd0d	;if we don't do this, a pending CIA irq might occur after we finish setting up our irq.
				;we don't want that to happen.
				
	lda #$35	;we turn off the BASIC and KERNAL rom here
	sta $01		;the cpu now sees RAM everywhere except at $d000-$e000, where still the registers of
				;SID/VICII/etc are visible
				
	lda #<irq	;this is how we set up
	sta $fffe	;the address of our interrupt code
	lda #>irq
	sta $ffff
	
	lda #$01   ;this is how to tell the VICII to generate a raster interrupt
	sta $d01a

	lda #$50   ;this is how to tell at which rasterline we want the irq to be triggered
	sta $d012

	lda #$1b   ;as there are more than 256 rasterlines, the topmost bit of $d011 serves as
	sta $d011  ;the 8th bit for the rasterline we want our irq to be triggered.
           ;here we simply set up a character screen, leaving the topmost bit 0.
		   
	lda #$c1   ; set the scroll as far left as possible.
	sta $d016
	sta scrollbit
		   
	lda #$1E	; Set the character map to be @ 0x3800
	sta $d018


;	asl $d019
; zero some stuff
	lda #$00
	sta intcount1
	sta intcount2
	sta scrollchr
	sta scrollpos
	jsr	clearscr
	cli			;enable maskable interrupts again

	jmp *	;we better don't RTS, the ROMS are now switched off, there's no way back to the system


clearscr:	ldx #$00
		lda #$20
clearscrl: sta $0400,x
		sta $0500,x
        sta $0600,x
        sta $0700,x
        dex
        bne clearscrl
	
dark:	lda $d020 ;copy border color into
		sta $d021 ;main area color
		
		
		ldx #$01
		lda #$01
		sta $d800
color:	lda #$02
		sta $d800,x
		sta $d900,x
		sta $da00,x
		inx
		cpx #$FF
		bne color
		rts
		
draw	ldx #$00
		ldy #$00
.loop	lda msgz,x
		sta $0428,y
		sec
		sbc #$40
		sta $0400,y
		iny
		clc
		adc #$80
		sta $0400,y
		clc
		adc #$40
		sta $0428,y
		inx
		iny
		cpx #$13
		bne .loop
		rts

; First move everything one step to the left
fillr	ldx #$00
.loopr	lda $0401,x
		sta $0400,x
		lda $0429,x
		sta $0428,x
		inx
		cpx #$28
		bne .loopr
; Now fill in more juicy stuff on the far right
		lda scrollchr
		cmp #$00
		beq newchar
oldchar	ldx scrollpos
		lda msgd,x
		clc
		adc #$40
		sta $0427
		clc
		adc #$40
		sta $044f
		lda #$00
		sta scrollchr
		inc scrollpos
		rts
		
newchar	ldx scrollpos
		lda msgd,x
		sta $044f
		sec
		sbc #$40
		sta $0427
		inc scrollchr
		rts
		
		
		
dscroll	dec scrollbit
		dec scrollbit
		lda scrollbit
		cmp #$bf
		bne setsrll
		jsr fillr
		lda #$c7
		sta scrollbit

setsrll sta $d016
		rts
		

		
static:	lda #$01
staticl:	sta $d021
		nop
		nop
		sta $d020
		eor #$1
		jmp staticl
		
		


	;Being all kernal irq handlers switched off we have to do more work by ourselves.
	;When an interrupt happens the CPU will stop what its doing, store the status and return address
	;into the stack, and then jump to the interrupt routine. It will not store other registers, and if
	;we destroy the value of A/X/Y in the interrupt routine, then when returning from the interrupt to
	;what the CPU was doing will lead to unpredictable results (most probably a crash). So we better
	;store those registers, and restore their original value before reentering the code the CPU was
	;interrupted running.

	;If you won't change the value of a register you are safe to not to store / restore its value.
	;However, it's easy to screw up code like that with later modifying it to use another register too
	;and forgetting about storing its state.

	;The method shown here to store the registers is the most orthodox and most failsafe.
irq     STA $02
        LDA $DC0D
        STX $03
        STY $04
;	Stack is now saved, lets party!
		inc $d020		;  visualize interrupt
		jsr $BDE4 ;Play some music
		; Lets see what we should be doing...
;init	lda #$00
;		cmp intcount1
;		bne dscr
;		cmp intcount2
;		bne dscr
		;jsr clearscr
;		jsr draw
		
dscr	lda #$50
		cmp intcount1
		bne prescr
prescr	lda #$00
		cmp intcount2
		;bne timer
		jsr dscroll
		
timer	inc intcount1
		lda intcount1
		cmp #$00
		bne restore
		inc intcount2
		
		
		
;	Restore stack
restore	dec $d020	; visualize interrupt
		LDA #$0F
        STA $D019
        LDY $04
        LDX $03
        LDA $02
        RTI

msgd .byte "DARKLITE`PRESENTS`"
msgz .byte "ZOMGTRONICS`PRESENTS`"

	org $3800
	INCBIN "fontbin"
	org $BC00-$7E
    INCBIN "Delta.sid"